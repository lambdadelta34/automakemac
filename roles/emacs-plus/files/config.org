#+TITLE: emacs config
#+OPTIONS: toc:nil

* Configuration
I forgot everything i've done in my previous init.el file, so i decided to start another one from scratch in org-mode to be able to write a lot about stuff happening here.
Also, i'd like to start using org-mode, finally.

** Config initialization

So, we need this to require emacs default package manager and be able to initialize them before configuring them.
[[https://wikemacs.org/wiki/Package.el][link to the doc]]
Also add melpa to package manager.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

This little dude here is enables lazy loading.

#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC

** use-package

This is where the fun begins. It is a elisp macro which goal is to simplify package configuration.
[[https://github.com/jwiegley/use-package][github link]]
Some elisp code to install it if it isn't yet. And ensure that all packages would be installed automatically if they are not.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

Check out for [[https://github.com/raxod502/straight.el][straight.el]] instead of use-package.

Mac os use PATH set by user shell. Just in case.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

* Preferences

Leader key for evil mode.

#+BEGIN_SRC emacs-lisp
(setq leader "SPC")
(setq alt-leader "C-SPC")
#+END_SRC

Font.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist
             '(font . "Hack Nerd Font 12"))
#+END_SRC

Removes unnecessary window docaration.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
#+END_SRC

Disable startup menu.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC

Window frame size.

#+BEGIN_SRC emacs-lisp
;; (toggle-frame-fullscreen)
(add-to-list 'default-frame-alist '(fullscreen . fullboth))
;; (add-hook )
;; (add-to-list 'default-frame-alist '(width . 200))
;; (add-to-list 'default-frame-alist '(height . 55))
#+END_SRC

Garbage collection threshold to 20 mb.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 20 1000 1000))
#+END_SRC

Force use of spaces instead of tabs, blahh. And tab width.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
#+END_SRC

Enable line numbers. I was confused when didn't see line numbers by default.

#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode)
#+END_SRC

Highlight corresponding parentheses when cursor is on one. (smartparentheses takes care of this)

#+BEGIN_SRC emacs-lisp
;; (show-paren-mode t)
;; (setq show-paren-style 'mixed)
#+END_SRC

Autorefresh buffers when file changes on disk.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

Remove useless whitespace before saving a file.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Stop creating annoying backup~ files.

#+BEGIN_SRC emacs-lisp
;; (setq make-backup-files nil)
#+END_SRC

Not that I needed to backup, but it's better to be safe than sorry.

#+BEGIN_SRC emacs-lisp
(setq vc-make-backup-files t ;; emacs doesn't do backup for VCed files
      version-control t      ;; Use version numbers for backups.
      kept-new-versions 10   ;; Number of newest versions to keep.
      kept-old-versions 0    ;; Number of oldest versions to keep.
      delete-old-versions t  ;; Don't ask to delete excess backup versions.
      backup-by-copying t    ;; Copy all files, don't rename them.
      backup-directory-alist '(("" . "~/.emacs.d/backup/per-save")))

(defun force-backup-of-buffer ()
    ;; Make a special "per session" backup at the first save of each
    ;; emacs session.
    (when (not buffer-backed-up)
      ;; Override the default parameters for per-session backups.
      (let ((backup-directory-alist '(("" . "~/.emacs.d/backup/per-session")))
            (kept-new-versions 3))
        (backup-buffer)))
    ;; Make a "per save" backup on each save.  The first save results in
    ;; both a per-session and a per-save backup, to keep the numbering
    ;; of per-save backups consistent.
    (let ((buffer-backed-up nil))
      (backup-buffer)))

(add-hook 'before-save-hook  'force-backup-of-buffer)
#+END_SRC

Stop creating not less annoying #autosave# files.

#+BEGIN_SRC emacs-lisp
(setq auto-save-default nil)
#+END_SRC

Silent ring bell(really, REALLY? DO I REALLY HAVE TO DO THIS??)

#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
(setq ring-bell-function 'ignore)
#+END_SRC

Use command as meta key.

#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'meta
      mac-option-modifier 'none)
#+END_SRC

Org-mode for *scratch* file.

#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'org-mode)
#+END_SRC

* Theme

Dracula, hocho, just a little bite.

#+BEGIN_SRC emacs-lisp
(use-package dracula-theme
  :config
  (load-theme 'dracula t))
#+END_SRC

Pretty symbols.

#+BEGIN_SRC emacs-lisp
(defun my/pretty-syms-hask ()
  (setq prettify-symbols-alist
        '(
          ("lambda" . 955)              ; λ
          ("\\" . 955)                  ; λ
          ("->" . 8594)                 ; →
          ("=>" . 8658)                 ; ⇒
          ("map" . 8614)                ; ↦
          ("forall" . 8704)             ; ∀
          ("exists" . 8707)             ; ∃
          ("<-" . 8592)                 ; ←
          ("~>" . 8604)                 ; ⇝
          ("<~" . 8605)                 ; ⇜
          ("&&" . 8743)                 ; ∧
          ("||" . 8744)                 ; ∨
          ("=" . 8797)                  ; ≝
          ("==" . 8801)                 ; ≡
          ("//=" . 8802)                ; ≢, ≠
          ("<=" . 8804)                 ; ≤
          (">=" . 8805)                 ; ≥
          ("//<" . 8814)                ; ≮
          ("//>" . 8815)                ; ≯
          ("*" . 8728)                  ; ⋅
          ("`elem`" . 8712)             ; ∈
          ("`notElem`" . 8713)          ; ∉
          ("`member`" . 8712)           ; ∈
          ("`notMember`" . 8713)        ; ∉
          ("`union`" . 8746)            ; ∪
          ("`intersection`" . 8745)     ; ∩
          ("`isSubsetOf`" . 8838)       ; ⊆
          ("`isProperSubsetOf`" . 8834) ; ⊂
          ("<<<" . 8920)                ; ⋘
          (">>>" . 8921)                ; ⋙
          ("<|" . 8882)                 ; ⊲
          ("|>" . 8883)                 ; ⊳
          ("><" . 8904)                 ; ⋈
          ("mappend" . 8853)            ; ⊕
          ("." . 8729)                  ; ∘
          ("undefined" . 8869)          ; ⊥
          )))
(add-hook 'haskell-mode-hook 'prettify-symbols-mode)
(add-hook 'haskell-mode-hook 'my/pretty-syms-hask)
#+END_SRC

* Packages
** Genaral(general.el, not general config)

[[https://github.com/noctuid/general.el][General]] is very convenient way to bind keys.

#+BEGIN_SRC emacs-lisp
(use-package general
  :config
  (general-evil-setup t)
  (general-define-key
    :states '(normal insert emacs)
    :prefix leader
    :non-normal-prefix alt-leader
    "wd" 'delete-window
    "wc" 'delete-other-windows
    "fed" (lambda () (interactive) (find-file user-init-file))
    "feR" 'eval-buffer
    "fs" 'save-buffer
    "qq" 'save-buffers-kill-terminal))
#+END_SRC

** EVIL mode
Because i like vim too.
*** Dependencies
Very cool stuff for undoing things.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :defer t
  :config
  (general-define-key
    :states 'normal
    :prefix leader
    "u" 'undo-tree-visualize)
  (global-undo-tree-mode)
  (setq undo-tree-auto-save-history t
        undo-tree-visualizer-diff t
        undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo"))))
#+END_SRC

Just functionality to go to last chages. Nothing fancy here.

#+BEGIN_SRC emacs-lisp
(use-package goto-chg)
#+END_SRC

*** Mode itself & stuff

[[https://github.com/emacs-evil/evil][Evil]] itself.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :defer t
  :preface
  (defun my/_as-word ()
    (modify-syntax-entry ?_ "w"))
  (defun my/tab2 ()
    (setq evil-shift-width 2))
  (defun my/copy-to-clipboard ()
    (interactive)
    (if (display-graphic-p)
        (progn
          (call-interactively 'clipboard-kill-ring-save))
      (if (region-active-p)
          (progn
            (shell-command-on-region (region-beginning) (region-end) "pbcopy")
            (deactivate-mark)))))

  (defun my/move-line-up ()
    (interactive)
    (transpose-lines 1)
    (forward-line -2))

  (defun my/move-line-down ()
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1))
  :init
  (setq evil-motion-state-modes nil
        evil-shift-width 2
        evil-want-keybinding nil)
  :config
  (evil-mode 1)
  (general-define-key
    :states '(normal insert)
    "C-k" 'evil-window-up
    "C-j" 'evil-window-down
    "C-h" 'evil-window-left
    "C-l" 'evil-window-right)

  (general-define-key
    :states 'normal
    "Q" 'quit-window
    "[e" 'my/move-line-down
    "]e" 'my/move-line-up)

  (general-define-key
    :states '(normal visual)
    "[e" 'my/move-line-down
    "]e" 'my/move-line-up)

  (general-define-key
    :states 'visual
    "y" 'my/copy-to-clipboard
    "gs" 'sort-lines)

  (general-define-key
    :states 'normal
    :prefix leader
    "wn" 'evil-window-split
    "w/" 'evil-window-vsplit)
  (add-hook 'view-mode-hook 'evil-motion-state)
  (add-hook 'ruby-mode-hook 'my/tab2)
  (add-hook 'js-mode-hook 'my/tab2)
  (add-hook 'prog-mode-hook 'my/_as-word))
#+END_SRC

[[https://github.com/emacs-evil/evil-collection][Evil-colletion]] replaces keys for some modes.

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :init
  (setq evil-collection-mode-list nil)
  (setq evil-collection-mode-list '(
    (buff-menu "buff-menu")
    company
    debug
    doc-view
    eshell
    evil-mc
    flycheck
    ibuffer
    info
    ivy
    help
    man
    outline
    (package-menu package)))
    ;; process-menu
    ;;simple))
    ;; view))
  :config
  (evil-collection-init))
#+END_SRC

[[https://github.com/emacs-evil/evil-surround][Surround mode]] mode for EVIL.

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+END_SRC

Adds [[https://github.com/wcsmith/evil-arg][args]] motions and text object.

#+BEGIN_SRC emacs-lisp
(use-package evil-args
  :general
  (:keymaps 'evil-inner-text-objects-map
    "a" 'evil-inner-arg)
  (:keymaps 'evil-outer-text-objects-map
    "a" 'evil-outer-arg))
#+END_SRC

Code [[https://github.com/redguardtoo/evil-nerd-commenter][commentary]].

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :defer t
  :general
  (:states 'normal
    "gy" 'evilnc-comment-or-uncomment-lines)
  (:states 'visual
    "gc" 'evilnc-comment-or-uncomment-lines))
#+END_SRC

*** Evil-daemon problem.
:PROPERTIES:
:CUSTOM_ID: evil-daemon
:END:

#+BEGIN_SRC emacs-lisp
;;  (unless (display-graphic-p)
;;    (add-hook 'evil-insert-state-entry-hook (lambda () (send-string-to-terminal "\033[5 q"))) ;; set cursor to bar
;;    (add-hook 'evil-normal-state-entry-hook (lambda () (send-string-to-terminal "\033[0 q"))))) ;; set cursor to block
#+END_SRC

** Indent guide

[[https://github.com/DarthFennec/highlight-indent-guides][Indent]] guide with vertical bars.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :init
  (setq highlight-indent-guides-method 'column
        highlight-indent-guides-delay 1
        highlight-indent-guides-responsive 'stack
        ;; highlight-indent-guides-auto-odd-face-perc 15
        ;; highlight-indent-guides-auto-even-face-perc 15
        ;; highlight-indent-guides-auto-character-face-perc 20
        )
  :config
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
  (add-hook 'highlight-indent-guides-mode-hook 'highlight-indent-guides-auto-set-faces))
#+END_SRC

** Expanding

[[https://github.com/magnars/expand-region.el][Expand region]] helpsto quickly select with expanding region.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :init
  (setq expand-region-contract-fast-key "z")
  :config
  (general-define-key
    :states 'normal
    :prefix leader
    "x" 'er/expand-region))
#+END_SRC

** Jumping

[[https://github.com/abo-abo/avy][Avy]] jump mode.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :config
  (general-define-key
    :states 'normal
    "gw" 'avy-goto-word-1
    "gc" 'avy-goto-char
    "gl" 'avy-goto-line))
#+END_SRC

** EMOJI!

[[https://github.com/iqbalansari/emacs-emojify][Emojification]] for emacs.

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :init
  (setq emojify-emoji-styles 'unicode)
  :config
  (global-emojify-mode))
#+END_SRC

** Info

[[https://github.com/justbur/emacs-which-key][which-key]] is a package which show info about key sequences.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer t
  :init
  (which-key-mode)
  :config
  (setq which-key-sort-order 'which-key-key-order-alpha
        which-key-side-window-max-height 0.33
        which-key-idle-delay 0.5))
#+END_SRC

[[https://github.com/emacsmirror/rainbow-mode][Rainbow-mode]] colors hexlike strings.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode)
#+END_SRC

[[https://github.com/raugturi/powerline-evil][Powerline]] like in vim.

Nyan compatibility achieved by patching source theme with
#+BEGIN_SRC emacs-lisp
;; (when (bound-and-true-p nyan-mode)
;;   (powerline-raw (list (nyan-create)) face2 'l))
#+END_SRC
and then recompiling it ~(byte-recompile-directory package-user-dir nil 'force)~.

#+BEGIN_SRC emacs-lisp
(use-package powerline
  :config
  (powerline-center-evil-theme))
#+END_SRC

[[https://github.com/elpa-host/goto-line-preview][Goto-line]] preview.

#+BEGIN_SRC emacs-lisp
(use-package goto-line-preview
  :config
  (general-define-key
    [remap goto-line] 'goto-line-preview))
#+END_SRC

** IVY & Search

Everybody looks for something. I do this with swiper and ag.
[[https://github.com/abo-abo/swiper][ivy/swiper]]

Ivy has a nice function `ivy-read` which does most of the job.
So, when you iterate over ivy candidates via `-and-call` functions you can call action, binded to called command, which, for grep commands, is to preview file.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :defer t
    :diminish (ivy-mode . "")
    :preface
    (defun my/kill-other-buffers ()
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
    ;; (defun quick-look (filename)
    ;;   (if filename
    ;;       (pcase (split-string filename ":")
    ;;         (
    ;;          `("")
    ;;          (message "No file provided")
    ;;          )
    ;;         (
    ;;          `(,filename)
    ;;          (view-file filename))
    ;;         (
    ;;          `(,filename ,line)
    ;;          (view-file filename)
    ;;          (goto-line (string-to-number line)))
    ;;         (
    ;;          `(,filename ,line ,column)
    ;;          (view-file filename)
    ;;          (goto-line (string-to-number line))
    ;;          (move-to-column (string-to-number column))))
    ;;     (message "No file provided"))
    ;;   )

    :general
    (:keymaps 'ivy-minibuffer-map
      "C-M-j" '(ivy-next-line-and-call :which-key "next line")
      "C-M-k" '(ivy-previous-line-and-call :which-key "prev line")
      "C-j" '(ivy-next-line :which-key "next line")
      "C-k" '(ivy-previous-line :which-key "prev line")
      "C-h" '(ivy-beginning-of-buffer :which-key "beginning of ivy minibuffer")
      ;; "C-l" '(ivy-end-of-buffer :which-key "end if ivy mini buffer")
      "C-l" '(ivy-immediate-done :which-key "exits from ivy search without selecting curent item")
      "C-v" '(ivy-scroll-up-command :which-key "page up ivy buffer")
      "M-v" '(ivy-scroll-down-command :which-key "page down ivy buffer"))
    (:states 'normal
      :prefix leader
      "bs" 'ivy-switch-buffer)
      ;; "bn" 'next-buffer
      ;; "bd" 'kill-this-buffer
      ;; "bp" 'previous-buffer
      ;; "bx" 'my/kill-other-buffers)

    :config
    (ivy-mode 1)
    (setcdr (assoc 'counsel-M-x ivy-initial-inputs-alist) "")
    (setq ivy-use-virtual-buffers t
          magit-completing-read-function 'ivy-completing-read
          ivy-height 20
          ivy-count-format "(%d/%d)"))
#+END_SRC

Wrapper around some emacs commands.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :defer t
  :preface
  (defun my/rg-word-visual ()
    (interactive)
    (counsel-rg (buffer-substring
                  (evil-range-beginning (evil-visual-range))
                  (evil-range-end (evil-visual-range)))))
  (defun my/rg-word ()
    (interactive)
    (counsel-rg (thing-at-point 'word)))
  :general
  ("M-x" 'counsel-M-x)
  (:states 'normal
    :prefix leader
    "*" 'my/rg-word)
  (:states 'visual
    :prefix leader
    "*" 'my/rg-word-visual)
  (:states 'normal
    :prefix leader
    "/" 'counsel-rg))
#+END_SRC

Search for ivy.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :defer t
  :preface
  (defun my/s-word()
    (interactive)
    (swiper (thing-at-point 'symbol)))
  :general
  (:states 'normal
    "*" 'my/s-word
    "/" 'swiper))
#+END_SRC

** Org stuff

Just for org-mode config.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil)
#+END_SRC

Pretty bullets.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :config
  (setq org-bullets-bullet-list '("∙"))
  (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

** Projectile

[[https://docs.projectile.mx/en/latest][Projects]], projects everywhere.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 2
  :preface
  (defun my/projectile-ranger ()
    "Use ranger instead of dired"
    (interactive)
    (ranger (projectile-ensure-project (projectile-project-root))))
  :init
  (projectile-mode +1)
  :config
  (setq projectile-completion-system 'ivy
        projectile-require-project-root nil
        projectile-switch-project-action 'my/projectile-ranger)
  ;; (counsel-projectile-mode)
  (general-define-key
    :states 'normal
    :keymaps 'projectile-mode-map
    :prefix leader
    "p" 'projectile-command-map
    "ff" 'projectile-find-file))
#+END_SRC

Counsel for projectile.
Meh, decided not to. Breaks projectile hooks.

#+BEGIN_SRC emacs-lisp
;; (use-package counsel-projectile
;;   :defer t)
#+END_SRC

[[https://github.com/leoliu/ggtags][ggtags]] for code navigation.

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :defer t
  :diminish 'ggtags-mode
  :general
  (:states 'normal
    "C-]" 'ggtags-find-tag-dwim))
#+END_SRC

** Search

I use [[https://github.com/Wilfred/ag.el][ag]].

#+BEGIN_SRC emacs-lisp
;; (use-package ag
;;   :defer t
;;   :config
;;   (setq ag-highlight-search t)
;;   (add-hook 'ag-mode-hook 'wgrep-change-to-wgrep-mode))
#+END_SRC

Or [[https://github.com/Wilfred/deadgrep][ripgrep]].

#+BEGIN_SRC emacs-lisp
(use-package deadgrep
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (use-package wgrep-ag)
#+END_SRC

** Magit

I heard [[https://github.com/magit/magit][magit]] to be best git client. Let's see.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t
  :init
  (general-define-key
    :states 'normal
    :prefix leader
    "g" 'magit-status)
  (general-define-key
    :prefix leader
    :states 'normal
    "C-b" 'magit-blame-addition))

#+END_SRC

And, surely, [[https://github.com/emacs-evil/evil-magit][evil-magit]].

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :after magit)
#+END_SRC

Gitgutter

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :config
  (global-git-gutter-mode t)
  :diminish
  git-gutter-mode)
#+END_SRC

** Ranger

[[https://github.com/ralesi/ranger.el][Ranger]] is for dired.

#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :config
    (setq ranger-show-hidden 'prefer)
    (add-to-list 'ranger-prefer-regexp "^\\.")
    (ranger-override-dired-mode 'ranger)
    (add-hook 'ranger-mode-hook 'all-the-icons-dired-mode)

    (general-define-key
     :states '(normal insert visual)
     "TAB" 'ranger)

    (general-define-key
      :keymaps 'ranger-normal-mode-map
      "c" 'find-file
      "f" 'projectile-find-file)
    (general-define-key
     :states 'normal
     :prefix leader
     "d" 'ranger))
#+END_SRC

Icons for dired and ranger.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :defer t)
(use-package all-the-icons-dired
  :defer t)
#+END_SRC

** Cursors

[[https://github.com/magnars/multiple-cursors.el][Multiple cursors]].

#+BEGIN_SRC emacs-lisp
;; (use-package multiple-cursors
;;   :config
;;   (setq mc/always-run-for-all t)
;;   :general
;;   (:states 'normal
;;     "C-S-n" 'mc/unmark-next-like-this
;;     "C-S-p" 'mc/unmark-previous-like-this
;;     "C-p" 'mc/mark-previous-like-this-word
;;     "C-n" 'mc/mark-next-like-this-word)
;;   (:states 'visual
;;     "C-S-n" 'mc/unmark-next-like-this
;;     "C-S-p" 'mc/unmark-previous-like-this
;;     "C-p" 'mc/mark-previous-like-this
;;     "C-n" 'mc/mark-next-like-this))
#+END_SRC

Evil [[https://github.com/gabesoft/evil-mc][multicursor]].

#+BEGIN_SRC emacs-lisp
(use-package evil-mc
  :config
  (global-evil-mc-mode  1)
  (general-define-key
    :states 'normal
    "grm" 'evil-mc-make-all-cursors
    "gru" 'evil-mc-undo-last-added-cursor
    "grq" 'evil-mc-undo-all-cursors
    "grs" 'evil-mc-pause-cursors
    "grr" 'evil-mc-resume-cursors
    "grf" 'evil-mc-make-and-goto-first-cursor
    "grl" 'evil-mc-make-and-goto-last-cursor
    "grh" 'evil-mc-make-cursor-here
    "grj" 'evil-mc-make-cursor-move-next-line
    "grk" 'evil-mc-make-cursor-move-prev-line
    "M-n" 'evil-mc-make-and-goto-next-cursor
    "grN" 'evil-mc-skip-and-goto-next-cursor
    "M-p" 'evil-mc-make-and-goto-prev-cursor
    "grP" 'evil-mc-skip-and-goto-prev-cursor
    "C-n" 'evil-mc-make-and-goto-next-match
    "grn" 'evil-mc-skip-and-goto-next-match
    "C-t" 'evil-mc-skip-and-goto-next-match
    "C-p" 'evil-mc-make-and-goto-prev-match
    "grp" 'evil-mc-skip-and-goto-prev-match))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :config
  (beacon-mode 1)
  (setq beacon-blink-when-focused t
        beacon-color "#ee6bff"
        beacon-blink-duration 0.5
        beacon-size 70
        beacon-blink-when-point-moves-vertically 15))
#+END_SRC

** Autocomplete

I'm not sure yet if i need it. We'll see.

There is no alternatives to [[http://company-mode.github.io/][company-mode]].

#+BEGIN_SRC emacs-lisp
(use-package company
  :defer t
  :init
  (global-company-mode)
  (setq company-idle-delay 0.1
        company-show-numbers t
        company-tooltip-align-annotations t
        company-selection-wrap-around t)
  :config
  (add-to-list 'company-backends 'company-yasnippet)
  (general-define-key
    :keymaps 'company-active-map
    "C-j" 'company-select-next
    "C-k" 'company-select-previous
    "C-p" 'company-other-backend
    "C-l" 'company-complete-selection)

  (general-define-key
    :states '(normal insert)
    :keymaps 'company-mode-map
    "C-p" 'company-complete))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (use-package company-box
;;   :hook (company-mode . company-box-mode))
#+END_SRC

Quickhelp too.
(not working properly with evil bindings)

#+BEGIN_SRC emacs-lisp
;; (use-package company-quickhelp
;;   :defer t
;;   :init
;;   (company-quickhelp-mode))
#+END_SRC

Why not irony.

#+BEGIN_SRC emacs-lisp
(use-package company-irony
  :defer t)
#+END_SRC

** Parentheses

Oh where would we be without them. Maybe coding on Haskell.

I love my [[https://github.com/Fuco1/smartparens][parenths]] smart.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :defer t
  :init
  (show-smartparens-global-mode t)
  (smartparens-global-mode 1)
  (sp-local-pair 'emacs-lisp-mode "'" nil :actions '(:rem insert))
  :custom-face
  (sp-show-pair-match-face ((t :foreground "#00ffff"
                               :background "#6700D4")))
  (sp-show-pair-match-content-face ((t :foreground "#00ffff"
                                       :background "#6700D4"))))
#+END_SRC

[[https://github.com/tsdh/highlight-parentheses.el][Highlight]] matching parentheses.

#+BEGIN_SRC emacs-lisp
(use-package highlight-parentheses
  :hook ((ruby-mode
          emacs-lisp-mode
          lisp-mode) . highlight-parentheses-mode)
  :defer t)
#+END_SRC

[[https://github.com/Fanael/rainbow-delimiters][Rainbow]] delimeters.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :config
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

** Tabs

[[https://github.com/manateelazycat/awesome-tab][Awesome tabs]] for tabs.

Author doesn't like melpa, so I have to git clone that stuff and update by pulling.

#+BEGIN_SRC emacs-lisp
(use-package awesome-tab
  :load-path "~/.emacs.d/aw-tab"
  :init
  (setq awesome-tab-style 'alternate
        awesome-tab-background-color "#282a36")
  :custom-face
  (awesome-tab-unselected ((t :background "#8BE9FD")))
  (awesome-tab-selected ((t :background "#bd93f9")))
  :config
  (awesome-tab-mode t)
  (general-define-key
    :states 'normal
    :prefix leader
    "bg" 'awesome-tab-build-ivy-source
    "bn" 'awesome-tab-forward
    "bp" 'awesome-tab-backward
    "bl" 'awesome-tab-select-end-tab
    "bf" 'awesome-tab-select-beg-tab
    "bd" 'kill-this-buffer
    "bx" 'awesome-tab-kill-other-buffers-in-current-group)
  )
#+END_SRC

** Term

Eshell config.

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :ensure nil
  :preface
  (defun my/eshell ()
    (interactive)
    (eshell '(-1)))
  :config
  (add-hook
    'eshell-mode-hook
    (lambda ()
      (setq pcomplete-cycle-completions nil)))
  ;; (general-define-key
  ;;   :states '(normal insert)
  ;;   "M-q" ) ;; eshell/exit
  (general-define-key
    :states '(normal insert)
    "C-," 'my/eshell))
    ;; "C-," 'eshell)) ;; "C-i" causes starting eshell with TAB too. crazy stuff
#+END_SRC

[[https://github.com/dieggsy/esh-autosuggest/][Eshell]] autosuggest.

#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode))
#+END_SRC

# Completion for fish.

#+BEGIN_SRC emacs-lisp
;; (use-package fish-completion
;;   :if (executable-find "fish")
;;   :config
;;   (global-fish-completion-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (use-package readline-complete
;;   :commands 'eshell)
#+END_SRC

Term extra info.

#+BEGIN_SRC emacs-lisp
(use-package eshell-prompt-extras
  :config
  (autoload 'epe-theme-lambda "eshell-prompt-extras")
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-lambda))
#+END_SRC

** Visual killring

[[https://github.com/browse-kill-ring/browse-kill-ring][Visual killring]] extension.

#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring
  :config
  (add-hook 'browse-kill-ring-hook 'evil-normal-state)
  (general-define-key
    :states 'normal
    :keymaps 'browse-kill-ring-mode-map
    "q" 'browse-kill-ring-quit
    "RET" 'browse-kill-ring-insert-and-quit)
  (general-define-key
    :states '(normal insert)
    "M-y" 'browse-kill-ring))

#+END_SRC

** LSP

Experimenting with [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]].

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :init
  (setq lsp-enable-snippet nil
        lsp-prefer-flymake nil
        lsp-auto-guess-root t
        ;; lsp-auto-configure nil
  )
)
#+END_SRC

Comes with [[https://github.com/emacs-lsp/lsp-ui][lsp-ui]].

#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :config
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
  (add-hook 'haskell-mode-hook 'flycheck-mode)
  ;; (add-hook 'ruby-mode-hook 'flycheck-mode)
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lsp-haskell
  :init
  (setq lsp-haskell-process-path-hie "hie-wrapper")
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-lsp
)
#+END_SRC

Try [[https://github.com/joaotavora/eglot][eglot]].

#+BEGIN_SRC emacs-lisp
;; (use-package eglot
;;   :config
;;   (add-to-list 'eglot-server-programs '(ruby-mode . ("solargraph" "stdio")))
;;   (add-to-list 'eglot-server-programs '(caml-mode . ("ocaml-language-server" "--stdio")))
;;   (add-to-list 'eglot-server-programs '(js-mode . ("javascript-typescript-stdio")))
;;   (add-to-list 'eglot-server-programs '(rjsx-mode . ("javascript-typescript-stdio")))
;;   (add-to-list 'eglot-server-programs '(reason-mode . ("ocaml-language-server" "--stdio")))
;;   (add-to-list 'eglot-server-programs '(haskell-mode . ("hie-wrapper")))

;;   ;; (add-hook 'ruby-mode-hook 'eglot-ensure)
;;   ;; (add-hook 'caml-mode-hook 'eglot-ensure)
;;   ;; (add-hook 'js-mode-hook 'eglot-ensure)
;;   ;; (add-hook 'rjsx-mode 'eglot-ensure)
;;   ;; (add-hook 'reason-mode-hook 'eglot-ensure)
;;   (add-hook 'haskell-mode-hook 'eglot-ensure))
#+END_SRC

** Lint

[[https://www.flycheck.org/en/latest/][Flycheck]] is good.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :defer t
  :preface
  (defun my/eslint-from-node-modules ()
    "function to find eslint in project folder, not globally"
    (let ((root (locate-dominating-file
                 (or (buffer-file-name) default-directory)
                 (lambda (dir)
                   (let ((eslint (expand-file-name "node_modules/.bin/eslint" dir)))
                     (and eslint (file-executable-p eslint)))))))
      (when root
        (let ((eslint (expand-file-name "node_modules/.bin/eslint" root)))
          (setq-local flycheck-javascript-eslint-executable eslint)))))
  :init
  (global-flycheck-mode)
  :config
  (add-hook 'flycheck-mode-hook 'my/eslint-from-node-modules)
  (add-hook 'flycheck-mode-hook 'ggtags-mode))
#+END_SRC

** Programming

[[https://github.com/joaotavora/yasnippet][Snippets]].

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :config
  (yas-global-mode 1)
)

(use-package yasnippet-snippets
)
#+END_SRC

[[https://github.com/yoshiki/yaml-mode][Yaml]] mode.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
)
#+END_SRC

[[https://github.com/slim-template/emacs-slim][Slim]].

#+BEGIN_SRC emacs-lisp
(use-package slim-mode
  )
#+END_SRC

[[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent]] keeps your code indented always.

#+BEGIN_SRC emacs-lisp
;; (use-package aggressive-indent
;;   :hook ((ruby-mode
;;           emacs-lisp-mode ;;           lisp-mode) . aggressive-indent-mode)
;;   :defer t)
#+END_SRC

Becuse i'm interested in haskell.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :defer t
  :mode
    ("\\.l?hs\\'" . haskell-mode)
  :preface
  (defun my/autocomplete ()
    (add-to-list 'company-backends 'company-ghc))
  :init
  (setq haskell-tags-on-save t
        tags-revert-without-query t
        haskell-process-type 'stack-ghci
        haskell-stylish-on-save t
        haskell-compile-cabal-build-command "stack build"
  )
  :config
  (general-define-key
    ;; :prefix leader
    :keymaps 'haskell-mode-map
    "C-]" 'haskell-mode-tag-find
  )
  (add-hook 'haskell-mode-hook 'my/autocomplete)
  ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-unicode-input-method) ;; nope
  (add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template)
  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
)

(use-package company-ghc)
#+END_SRC

Irony for C.

#+BEGIN_SRC emacs-lisp
(use-package irony
  :hook (c-mode . irony-mode))
#+END_SRC

And sometimes need to work with js.

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :defer t
  :mode "\\.js\\'"
  :config
  (setq-default js2-strict-trailing-comma-warning nil))
#+END_SRC

And rjsx.

#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :defer t)
#+END_SRC

Ruby mode settings.

This code adds car regexg to cdr face family. Basically car gets style of cdr.
Oh, and this chages apply to ruby-mode.

#+BEGIN_SRC emacs-lisp
;; (font-lock-add-keywords 'ruby-mode
;;     '(("FOOD" . font-lock-function-name-face)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :ensure nil
  :preface
  (defun my/rubocop-fix-file ()
    (interactive)
    (let ((cop-filename (buffer-file-name)))
      (message (concat "rubocop fixing the " cop-filename))
      (with-temp-buffer
        (async-shell-command (format "%s %s" flycheck-ruby-rubocop-executable
                              (concat "-a " cop-filename))
                      t))))

  (defun my/rubocop-fix-file-and-revert ()
    (interactive)
    (my/rubocop-fix-file))
    ;; (revert-buffer t t))

  :init
  (setq ruby-insert-encoding-magic-comment nil
        flycheck-ruby-rubocop-executable "rubocop")

  :general
  (:states 'normal
    :prefix leader
    "rfx" 'my/rubocop-fix-file)

  :config
  (font-lock-add-keywords 'ruby-mode
        '(("\\([A-Z][a-z]*?\\)\(.*?\)" 1 font-lock-function-name-face))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ruby-end)
#+END_SRC

Pry.

#+BEGIN_SRC emacs-lisp
(use-package inf-ruby
  :config
  (general-define-key
    :keymaps 'rspec-compilation-mode-map
    :states 'normal
    :prefix leader
    "rx" 'inf-ruby-switch-from-compilation))
#+END_SRC

Run specs from emacs.

#+BEGIN_SRC emacs-lisp
;; (use-package rspec-simple
;;   :config
;;   (general-define-key
;;     :keymaps 'ruby-mode-map
;;     :states 'normal
;;     :prefix leader
;;     "tt" 'rspec-find-related-file
;;     "rtn" 'rspec-compile-on-line
;;     "rtf" 'rspec-compile-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rspec-mode
  :config
  (add-hook 'after-init-hook 'inf-ruby-switch-setup)
  (general-define-key
    :states 'normal
    :prefix leader
    "rtt" 'rspec-toggle-spec-and-target
    "rtf" 'rspec-verify
    "rtm" 'rspec-verify-matching
    "rtn" 'rspec-verify-single))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (use-package ruby-test-mode
;;   :config
;;   (general-define-key
;;     :keymaps 'ruby-test-mode-map
;;     :states 'normal
;;     :prefix leader
;;     "rtn" 'ruby-test-run-at-point
;;     "rtf" 'ruby-test-run))
#+END_SRC

* Fun
** Nyan-cat

[[https://github.com/TeMPOraL/nyan-mode][Nyan cat]] in the tray.

#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :init
  ;; (setq nyan-wavy-trail t
  ;;       nyan-animate-nyancat t)
  :config
  (nyan-mode))
#+END_SRC

* TODOs
* Problems to solve
** TODO .dir-locals.el with ranger
It just freezes. Fix that.
** DONE emacsclient from mac os launchpad
For now I use function with focus on frame.
** TODO eshell at-point-autocomplete(or maybe use term)
** DONE disable TABing eshell in modes other than org
** DONE emacs --daemon doesn't open files
Strange thing with termcap. "Device is not a termcap terminal device".
Happend to be some bug with evil mode post-command-hook (evil-mode-check-buffers).
[[#evil-daemon]] - caused problem. I gotta look into how to make it lazy.
** DONE emacs --daemon doesn't know about projects at startup
Related to evil stuff. [[#evil-daemon]] problem.
